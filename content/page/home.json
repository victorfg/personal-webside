{
  "rows": [
    {
      "title": "Server Components vs Client Components in Next.js 14+",
      "summary": "With the arrival of Next.js 13 and its stabilization in Next.js 14+, React Server Components (RSC) have radically changed the way we build React applications. But when should you use Server Components and when Client Components?",
      "blocks": [
        {
          "block": "![](</uploads/ChatGPT Image Feb 11, 2026, 06_47_41 PM.png>)\n\n## Introduction\n\nWith the arrival of Next.js 13 and its stabilization in Next.js 14+, **React Server Components (RSC)** have fundamentally changed how we build React applications.\n\nBut when should you use Server Components and when Client Components?\n\nIn this post, I‚Äôll explain it clearly and practically, with real-world examples and proven patterns.\n\n## What Are Server Components?\n\n**Server Components** are React components that render exclusively on the server. They don‚Äôt ship JavaScript to the client, resulting in smaller bundles, faster initial loads, and better scalability.\n\nIn Next.js 14+, Server Components are the default in the App Router.\n\n### Key Features\n\n* Execute only on the server\n* Can directly access databases, file systems, and private APIs\n* Don‚Äôt increase client bundle size\n* Improve performance and SEO\n* Support streaming and partial rendering\n* Are the default behavior in Next.js 14+ (App Router)\n\nBy default, components in the `app` directory are Server Components unless you explicitly mark them with `'use client'`.\n\n### Example\n\n```tsx\nasync function PostsPage() {\n  const posts = await fetch('https://api.example.com/posts').then(r => r.json());\n  return (\n    <div>\n      <h1>Posts</h1>\n      {posts.map(post => (\n        <article key={post.id}>\n          <h2>{post.title}</h2>\n          <p>{post.excerpt}</p>\n        </article>\n      ))}\n    </div>\n  );\n}\n\nexport default PostsPage;\n```\n\nThis component runs entirely on the server. No JavaScript from this component is sent to the browser.\n\n## What Are Client Components?\n\nClient Components are traditional React components that run in the browser.\nThey must be explicitly marked with the 'use client' directive.\n\nClient Components are necessary whenever you need interactivity or access to browser APIs.\n\n### Key Features\n\n* Execute in the browser\n* Can use React hooks (useState, useEffect, useContext, etc.)\n* Handle user interactions\n* Access browser APIs (window, localStorage, etc.)\n* Require the 'use client' directive\n* Increase the JavaScript bundle sent to the client\n\n```javascript\n'use client'\n\nimport { useState } from 'react';\n\nexport function Counter() {\n  const [count, setCount] = useState(0);\n\n  return (\n    <div>\n      <p>Count: {count}</p>\n      <button onClick={() => setCount(count + 1)}>\n        Increment\n      </button>\n    </div>\n  );\n}\n\n```\n\n## Server vs Client Components: Direct Comparison\n\n| **Feature**           | **Server Component** | **Client Component**  |\n| --------------------- | -------------------- | --------------------- |\n| Rendering             | Server               | Browser               |\n| JavaScript in bundle  | ‚ùå No                 | ‚úÖ Yes                 |\n| React Hooks           | ‚ùå No                 | ‚úÖ Yes                 |\n| Database access       | ‚úÖ Direct             | ‚ùå Only via API        |\n| Interactivity         | ‚ùå No                 | ‚úÖ Yes                 |\n| Event handlers        | ‚ùå No                 | ‚úÖ Yes                 |\n| SEO                   | ‚úÖ Excellent          | ‚ö†Ô∏è Depends            |\n| Default in App Router | ‚úÖ Yes                | ‚ùå No (`'use client'`) |\n\n## When to Use Server Components\n\n* üìä You need to fetch data\n* üóÑÔ∏è You access a database directly\n* üîê You handle sensitive information (API keys, tokens)\n* üì¶ You want to reduce bundle size\n* üöÄ You want better initial performance\n* üìà SEO is important\n\n### Typical Use Cases\n\n* Blog posts and content pages\n* Product listings in e-commerce\n* Dashboards with server-side data\n* Static layouts and templates\n* CMS-driven pages\n\n## When to Use Client Components\n\n* üñ±Ô∏è You handle user events (onClick, onChange)\n* üì± You use React hooks (useState, useEffect, useContext)\n* üé® You need interactive animations\n* üåê You access browser APIs (localStorage, window)\n* üéØ You implement interactive forms\n* üîÑ You manage local state\n\n### Typical Use Cases\n\n* Buttons and counters\n* Forms and validations\n* Modals and dialogs\n* Carousels and sliders\n* Theme switchers\n* Drag-and-drop components\n\n## Core Principle: Server First, Client When Needed\n\n> Everything should be a Server Component by default. Use Client Components only when interactivity is required.\n\nThis approach minimizes JavaScript sent to the browser and maximizes performance.\n\n## Pattern 1: Composing Server and Client Components\n\nServer Components can render Client Components, but not the other way around.\n\n‚úÖ Correct Approach\n\n```javascript\n// app/page.tsx (Server Component)\nimport { Counter } from '@/components/Counter';\n\nasync function HomePage() {\n  const data = await fetchData();\n\n  return (\n    <div>\n      <h1>Server Component Data</h1>\n      <p>{data.title}</p>\n      <Counter />\n    </div>\n  );\n}\n\nexport default HomePage;\n\n```\n\n‚ùå Incorrect Approach\n\n```javascript\n'use client'\n\nimport { ServerData } from './ServerData';\n\nexport function ClientWrapper() {\n  return <ServerData />;\n}\n\n```\n\n‚ùó Client Components cannot import Server Components.\n\n## Pattern 2: Minimize Client Components\n\nKeep most of your application as Server Components and extract only the interactive parts.\n\nExample: Blog Post Page\n\n```javascript\nasync function PostPage({ params }) {\n  const post = await getPost(params.slug);\n\n  return (\n    <article>\n      <h1>{post.title}</h1>\n      <p>{post.date}</p>\n      <div>{post.content}</div>\n\n      <LikeButton postId={post.id} />\n      <CommentForm postId={post.id} />\n    </article>\n  );\n}\n\n```\n\n```javascript\n'use client'\n\nimport { useState } from 'react';\n\nexport function LikeButton({ postId }) {\n  const [liked, setLiked] = useState(false);\n\n  return (\n    <button onClick={() => setLiked(!liked)}>\n      {liked ? '‚ù§Ô∏è' : 'ü§ç'} Like\n    </button>\n  );\n}\n\n```\n\n## Pattern 3: Passing Server Components as Children\n\nYou can pass Server Components as children to Client Components.\n\n```javascript\n'use client'\n\nimport { useState } from 'react';\n\nexport function ClientWrapper({ children }) {\n  const [isOpen, setIsOpen] = useState(false);\n\n  return (\n    <div>\n      <button onClick={() => setIsOpen(!isOpen)}>Toggle</button>\n      {isOpen && children}\n    </div>\n  );\n}\n\n```\n\n```javascript\nimport { ClientWrapper } from '@/components/ClientWrapper';\n\nasync function HomePage() {\n  const data = await fetchData();\n\n  return (\n    <ClientWrapper>\n      <div>\n        <h2>{data.title}</h2>\n        <p>{data.description}</p>\n      </div>\n    </ClientWrapper>\n  );\n}\n\n```\n\n## Best Practices\n\n#### 1. Server Components by Default\n\nAlways start with Server Components. Add 'use client' only when necessary.\n\n#### 2. Reduce Client-Side JavaScript\n\nLess JavaScript in the browser = faster load times and better UX.\n\n#### 3. Use Composition Patterns\n\nCombine Server and Client Components strategically.\n\n#### 4. Use Serializable Props\n\nClient Component props must be serializable (no functions, raw Dates, etc.).\n\n#### 5. Fetch Data on the Server\n\nPrefer Server Components over useEffect for data fetching.\n\n## Conclusion\n\nServer Components in Next.js 14+ represent a paradigm shift in how we build React applications. The key takeaways are:\n\n* üéØ Use Server Components by default for better performance and SEO\n* üé® Extract Client Components only when you need interactivity\n* üîß Compose both intelligently to leverage the best of both worlds\n* üì¶ Reduce JavaScript bundle size for faster applications\n\nRemember: not everything needs to be interactive, and that's good news for your application's performance.\n\nBy following these patterns and best practices, you'll build faster, more efficient React applications that provide a better user experience.\n\n## Additional Resources\n\nNext.js Documentation - [Server Components](https://nextjs.org/docs/app/building-your-application/rendering/server-components)\n\nReact Documentation - [Server Components](https://react.dev/reference/rsc/server-components)\n\nVercel - Understanding [Server Components](https://vercel.com/blog/understanding-react-server-components)\n\nNext.js App Router [Migration Guide](https://nextjs.org/docs/app/building-your-application/upgrading/app-router-migration)\n"
        }
      ],
      "tags": [
        "serverComponents",
        "NextJS",
        "Performance",
        "React"
      ],
      "date": "2026-02-11T00:00:00.000Z"
    },
    {
      "title": "Git Strategies",
      "summary": "Ship/Show/Ask is a branching strategy that combines the features of Pull Requests with the ability to keep shipping changes.",
      "blocks": [
        {
          "block": "![](/uploads/git.jpeg)\n\n###### **Pull requests** are widely used in software teams, offering excellent code review tools and services. However, they have downsides. They've shifted the focus away from quickly shipping features, as work-in-progress features delay integration. This creates problems addressed by Continuous Integration. Pull Requests sometimes stagnate, become overly complex, or leave contributors unsure of what to tackle next. Moreover, the sheer volume of PRs can lead to fatigue, resulting in less attention to code quality during reviews.\n\n### Ship / Show / Ask\n\n#### Ship\n\nThis approach aligns closely with Continuous Integration. It's like when you want to make a change, and you go ahead and implement it directly on your main development line. When you do this, you don't wait for someone else to push your change into the production environment. You don't ask for a formal code review. It's a straightforward process where you implement the change, employing all the regular Continuous Integration techniques to ensure it's safe and functional.\n\nThis method works effectively when:\n\n* You're adding a feature using a well-established pattern.\n* You're fixing a straightforward bug.\n* You're updating documentation.\n* You're enhancing your code based on received feedback.\n\n#### Show\n\nIn this scenario, you blend the Continuous Integration mindset with the advantages of Pull Requests. You make changes on a separate branch, create a Pull Request, and merge it without waiting for explicit approval. While you wait for automated checks like tests, code coverage, and preview environments, you don't stall for feedback to deploy your changes.\n\nThis method enables quick deployment while still fostering a platform for feedback and discussions. Your team receives notifications about your pull request and can review your work, providing feedback on your code or approach, asking questions, and gaining insights from your changes.\n\nThis approach is effective when:\n\n* Seeking feedback to enhance code quality.\n* Presenting a new approach or pattern.\n* Refactoring code and showcasing the improvements.\n* Demonstrating a unique bug fix and its solution.\n\n#### Ask\n\nWe're making our changes on a separate branch, then we open a Pull Request, and we take a moment to wait for feedback before merging those changes into the main code. This pause might happen because we're uncertain if we've chosen the best approach, or there might be some parts of the code that we're not entirely satisfied with and want suggestions for improvement. Sometimes, it could be an experiment, and we're curious about people's opinions.\n\nModern tools for reviewing code provide an excellent platform for this type of discussion. They allow an entire team to come together, review a Pull Request, and have discussions about it.\n\nThis approach works well when:\n\n* We're unsure if our approach will succeed.\n* We want opinions on a new way of doing things.\n* We need assistance to improve our work.\n* We're wrapping up for the day and plan to merge the next day.\n\noriginal article: [https://martinfowler.com/articles/ship-show-ask.html](https://martinfowler.com/articles/ship-show-ask.html)\n\nThanks for reading!\n"
        }
      ],
      "tags": [
        "Git"
      ],
      "date": "2024-01-08T23:00:00.000Z"
    },
    {
      "title": "React Context Provider Hell",
      "summary": "The 'Context Provider Hell' in React is a common issue faced by developers.",
      "blocks": [
        {
          "block": "![](/uploads/retina_1708x683_cover-react-context-api-4929b3703a1a7082d99b53eb1bbfc31f.png)\n\nThe 'Context Provider Hell' in React is a common issue faced by developers. It arises when multiple Context Providers are nested, which leads to increased complexity and a dense 'wrapper hell' that can be hard to debug and maintain. This article delves into this issue and provides effective strategies to overcome it.\n\n## What is Context in React?\n\nReact Context provides a way to pass data through the component tree without having to pass props down manually at every level, essentially addressing the problem of \"prop drilling\". A context in React is primarily comprised of two parts:\n\n1. Context.Provider: It allows components in the tree to access the context's value.\n2. Context.Consumer: It consumes the value from the nearest Provider in the tree.\n\nThis works beautifully for small to medium-sized applications, but problems start to emerge as the application scales up.\n\n## The 'Context Provider Hell'\n\nAs the complexity of your React application increases, you might find yourself having multiple context providers. Each provider has its responsibility, and as a consequence, your component tree starts looking something like this:\n\n```jsx\n<Provider1>\n  <Provider2>\n    <Provider3>\n      <Provider4>\n        <Provider5>\n          <Component />\n        </Provider5>\n      </Provider4>\n    </Provider3>\n  </Provider2>\n</Provider1>\n```\n\nThis is known as the 'Context Provider Hell', and it can lead to several issues:\n\n1. Readability: It becomes difficult to understand the code. The complexity of the providers makes it hard to understand the context and the values being provided.\n2. Maintainability: It becomes harder to modify the code as your project grows.\n3. Performance: Each context provider can trigger a re-render in its consumers, even if the data they provide doesn't change. This can cause performance issues.\n\nSo, how do we mitigate these issues?\n\n## Mitigating the 'Context Provider Hell'\n\nHere are a few strategies to deal with the Context Provider Hell:\n\n### Combine Providers\n\nInstead of having many individual providers, combine them into a single one. This can be done by creating a utility function that combines all of the providers into a single component:\n\n```jsx\nconst AllProviders = ({ children }) => (\n  <Provider1>\n    <Provider2>\n      <Provider3>\n        <Provider4>\n          <Provider5>\n            {children}\n          </Provider5>\n        </Provider4>\n      </Provider3>\n    </Provider2>\n  </Provider1>\n);\n\n// Usage\n<AllProviders>\n  <Component />\n</AllProviders>\n```\n\nThe above approach tidies up the code but does not completely solve the underlying issue. It merely shifts the problem to another location in the codebase.\n\n### Use a State Management Library\n\nAnother solution is to use a state management library, like Redux, MobX, or Zustand. These libraries abstract the provider pattern and handle updates efficiently to minimize re-renders.\n\n### Use Higher-Order Components (HOCs)\n\nHigher-Order Components are a way to reuse component logic. They take a component and return a new component with additional props or behavior. Here's how you can use HOCs to mitigate 'Context Provider Hell':\n\n```jsx\nconst withProviders = (Component) => {\n  return () => (\n    <Provider1>\n      <Provider2>\n        <Provider3>\n          <Provider4>\n            <Provider5>\n              <Component />\n            </Provider5>\n          </Provider4>\n        </Provider3>\n      </Provider2>\n    </Provider1>\n  );\n};\n\n// Usage\nconst EnhancedComponent = withProviders(MyComponent);\n\n// Render EnhancedComponent\n<EnhancedComponent />\n```\n\nIn conclusion, the power of Context in React is indisputable, providing a clear solution to prop drilling and simplifying data flow. However, it's crucial to be aware of the pitfalls of over-reliance on Context Providers, one of which is 'Context Provider Hell'.\n\nWhile the complexity may seem overwhelming, employing strategies such as combining providers, leveraging state management libraries, and using higher-order components (HOCs) can help you manage this issue effectively.\n\nThese solutions serve as stepping stones towards more readable, maintainable, and performant React applications. So, next time you find yourself facing the tangled labyrinth of 'Context Provider Hell', we hope these strategies will guide you through.\n\nAs software developers, we continually strive for code that is not just functional but is also manageable and scalable. Let's apply these practices to ensure our journey in building applications is more a well-orchestrated symphony than a chaotic cacophony.\n\nThank you for reading this article. We hope it sheds light on navigating through 'Context Provider Hell' in React. As you continue developing with React, keep these strategies in mind, continually striving for better code organization and performance. Happy coding!\n"
        }
      ],
      "tags": [
        "Provider",
        "React"
      ],
      "date": "2023-06-05T22:00:00.000Z"
    },
    {
      "title": "Async await and Fetch",
      "summary": "Ah, Async/await and fetch! The dynamic duo of JavaScript that can save you from callback hell.",
      "blocks": [
        {
          "block": "![](/uploads/asyncawait.jpeg)\n\nAh, Async/await and fetch! The dynamic duo of JavaScript that can save you from callback hell and make your code look like a superhero.\n\nThink of Async/await as the Batman to your Robin. It allows you to write asynchronous code that's easier to read and understand. It's like a trusty sidekick that helps you avoid callback disasters and keeps your code from turning into a supervillain.\n\nFetch, on the other hand, is like the Spider-Man to your Iron Man. It's a powerful tool that allows you to send HTTP requests and get data from APIs like a web-slinging hero. It's fast, it's efficient, and it's always ready to swing into action.\n\nTogether, Async/await and fetch make a formidable team that can conquer any coding challenge. Imagine them as the Avengers of your codebase, taking on the forces of bad syntax and spaghetti code.\n\nLet's take a closer look at these two superheroes in action.\n\nFirst up, Async/await. It's like a utility belt that allows you to write asynchronous code without getting tangled up in callback chains. With Async/await, you can wait for a promise to resolve before moving on to the next step. It's like having the Flash by your side, allowing you to move at lightning speed through your code.\n\nHere's an example of Async/await in action:\n\n```javascript\nasync function getData() {\n  const response = await fetch('https://api.example.com/data');\n  const data = await response.json();\n  return data;\n}\n\ngetData().then(data => {\n  console.log(data);\n});\n```\n\nNow, onto fetch. It's like a shield that protects you from the dangers of unreliable APIs. Fetch allows you to send HTTP requests and receive responses in a clean and efficient way. It's like having Captain America by your side, shielding you from bad data and errors.\n\nHere's an example of fetch in action:\n\n```javascript\nfetch('https://api.example.com/data')\n  .then(response => response.json())\n  .then(data => {\n    console.log(data);\n  });\n```\n\nTogether, Async/await and fetch are a dynamic duo that can help you write better code and save the day. They're like the Batman and Robin, the Spider-Man and Iron Man, the Avengers of your codebase.\n\nSo next time you're facing a coding challenge, remember to call on the power of Async/await and fetch. They're always ready to lend a hand, like true superheroes.\n"
        }
      ],
      "tags": [
        "Promises",
        "Fetch API",
        "AsyncAwait"
      ],
      "date": "2023-03-26T22:00:00.000Z"
    },
    {
      "title": "Clone object in Javascript",
      "summary": "Often times, we want to create copies of variables for different purposes.",
      "blocks": [
        {
          "title": "Clone object in javascript",
          "block": "![](/uploads/VSMClonePattern.jpg)\n\nOften times, we want to create copies of variables for different purposes. There can be two different kinds of copies created - Shallow copy and Deep copy. Let's go over the terminologies and related examples:\n\n#### Shallow Copy\n\nShallow copying means it only copies the normal object values but nested values still use the reference to an original object. This means that modifications made in one place would affect both places.\n\nThere are two methods to do it. With Spread Operator (‚Ä¶) and Object.assign().\n\n```javascript\nconst obj = {a:10, b:20, c:{d:30}};\nconst shallowClone = {...obj};\nobj.c.d = 34; // updates the d property value\nconsole.log(obj); // {a:10,b:20,c:{d:34}}\nconsole.log(shallowClone); // {a:10,b:20,c:{d:34}}\n```\n\n#### Deep Copy\n\nDeep copy method creates a copy where the source and the copied variable reference are completely different. It means that modifications made in one place would only affect the variable where we are making a change.\n\nif the objects/arrays are not nested, then we can achieve deep copy by using Spread (...) operator:\n\n```javascript\nconst first_person = {\n  name: \"Manel\",\n  age: 34,\n}\n\nconst second_person = { ...first_person };\n\nsecond_person.age = 35;\n\nconsole.log(first_person.age); // output: 34\nconsole.log(second_person.age); // output: 35\n```\n\nIn case of nesting, the spread operator creates a shallow copy.\n\n###### If the objects/arrays are nested, then we can achieve deep copy by using JSON.parse() and JSON.stringify()\n\n```javascript\nconst obj = {a:10, b:20, c:{d:30}};\nconst deepClone = JSON.parse(JSON.stringify(obj));\nobj.c.d = 35;\n\n// d value is changed\nconsole.log(obj); // {a:10,b:20,c:{d:35}}\n\n// d value remains unchanged because there is no reference\nconsole.log(deepClone); // {a:10,b:20,c:{d:30}}\n```\n\nReferences:\n\n* [https://developer.mozilla.org/en-US/docs/Glossary/Deep\\_copy](https://developer.mozilla.org/en-US/docs/Glossary/Deep_copy)\n* [https://developer.mozilla.org/en-US/docs/Glossary/Shallow\\_copy](https://developer.mozilla.org/en-US/docs/Glossary/Shallow_copy)\n"
        }
      ],
      "tags": [
        "Objects",
        "Javascript"
      ],
      "date": "2023-02-13T23:00:00.000Z"
    },
    {
      "title": "Good practices in React",
      "summary": " Here's a summary of an article discussing good practices in React.",
      "blocks": [
        {
          "block": "![](/uploads/lautaro-andreani-xkBaqlcqeb4-unsplash.jpg)\n\n### *Use an object for update multiple states*\n\nReact state keeps track of the data which when changed triggers the React component to re-render.  The more data you have to keep track of across your app.\n\n```javascript\nconst [state, setState] = useState({\n  gender: \"\",\n  name: \"\",\n  age: 23\n});\n\nconst onClick = () => {\n  setState((prevState) => ({\n    ...prevState,\n    age: prevState.age + 1,\n    name: \"John\",\n    gender: 'male',\n  }));\n};\n```\n\n### *Avoid using indexes as key props*\n\nWith keys, React can point which item has been changed, added, or removed from the array.\n\nIt is not recommended recommend using indexes for keys if the order of items may change.\n\n```javascript\nconst todoItems = todos.map((todo) =>\n  <li key={todo.id}>\n    {todo.text}\n  </li>\n);\n```\n\n[https://reactjs.org/docs/lists-and-keys.html](https://reactjs.org/docs/lists-and-keys.html)\n\n### *Use object destructuring for props*\n\nIt's cleaner and easy to read\n\n```javascript\nconst Button = ({text}) => {\n  return <button>{text}</button>;\n};\n```\n\n### *Use Object Literals*\n\nIt's make our code more readable.\n\nIn this example we can't use ternary because there are more than two options and it's better to start using if's.\n\n```javascript\nconst {type} = animals\n\nconst components = {\n  LION: AdminUser,\n  CAT: EmployeeUser,\n  DOG: NormalUser\n};\n\nconst Component = components[type];\n\nreturn <Component />;\n```\n\n### *Keep render as clean as possible*\n\nMinimum logic inside render components.\n\n```javascript\nconst getUsers = () => dispatch(ACTION_GET_USERS)\n\nreturn (\n  <button onClick={getUsers}>\n    getUsers Button\n  </button>\n)\n```\n\n### *Use Template Literals*\n\nTry to avoid using string concatenation.\n\n```javascript\nconst animalDetails = `${animal.name} lives in ${animal.country} and eats ${animal.food}`\n\nreturn (\n  <div> {animalDetails} </div>\n)\n```\n\n### *Conclusion*\n\nCongratulations if you've made it this far! I hope you learned a thing or two from this article.\n\nI hope you have a wonderful day!\n"
        }
      ],
      "tags": [
        "Javascript",
        "React"
      ],
      "date": "2022-12-09T23:00:00.000Z"
    }
  ]
}