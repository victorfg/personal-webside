{
  "rows": [
    {
      "title": "Git Strategies",
      "summary": "Ship/Show/Ask is a branching strategy that combines the features of Pull Requests with the ability to keep shipping changes.",
      "blocks": [
        {
          "block": "![](/uploads/git.jpeg)\n\n###### **Pull requests** are widely used in software teams, offering excellent code review tools and services. However, they have downsides. They've shifted the focus away from quickly shipping features, as work-in-progress features delay integration. This creates problems addressed by Continuous Integration. Pull Requests sometimes stagnate, become overly complex, or leave contributors unsure of what to tackle next. Moreover, the sheer volume of PRs can lead to fatigue, resulting in less attention to code quality during reviews.\n\n### Ship / Show / Ask\n\n#### Ship\n\nThis approach aligns closely with Continuous Integration. It's like when you want to make a change, and you go ahead and implement it directly on your main development line. When you do this, you don't wait for someone else to push your change into the production environment. You don't ask for a formal code review. It's a straightforward process where you implement the change, employing all the regular Continuous Integration techniques to ensure it's safe and functional.\n\nThis method works effectively when:\n\n* You're adding a feature using a well-established pattern.\n* You're fixing a straightforward bug.\n* You're updating documentation.\n* You're enhancing your code based on received feedback.\n\n#### Show\n\nIn this scenario, you blend the Continuous Integration mindset with the advantages of Pull Requests. You make changes on a separate branch, create a Pull Request, and merge it without waiting for explicit approval. While you wait for automated checks like tests, code coverage, and preview environments, you don't stall for feedback to deploy your changes.\n\nThis method enables quick deployment while still fostering a platform for feedback and discussions. Your team receives notifications about your pull request and can review your work, providing feedback on your code or approach, asking questions, and gaining insights from your changes.\n\nThis approach is effective when:\n\n* Seeking feedback to enhance code quality.\n* Presenting a new approach or pattern.\n* Refactoring code and showcasing the improvements.\n* Demonstrating a unique bug fix and its solution.\n\n#### Ask\n\nWe're making our changes on a separate branch, then we open a Pull Request, and we take a moment to wait for feedback before merging those changes into the main code. This pause might happen because we're uncertain if we've chosen the best approach, or there might be some parts of the code that we're not entirely satisfied with and want suggestions for improvement. Sometimes, it could be an experiment, and we're curious about people's opinions.\n\nModern tools for reviewing code provide an excellent platform for this type of discussion. They allow an entire team to come together, review a Pull Request, and have discussions about it.\n\nThis approach works well when:\n\n* We're unsure if our approach will succeed.\n* We want opinions on a new way of doing things.\n* We need assistance to improve our work.\n* We're wrapping up for the day and plan to merge the next day.\n\noriginal article: [https://martinfowler.com/articles/ship-show-ask.html](https://martinfowler.com/articles/ship-show-ask.html)\n\nThanks for reading!\n"
        }
      ],
      "tags": [
        "Git"
      ],
      "date": "2024-01-08T23:00:00.000Z"
    },
    {
      "title": "React Context Provider Hell",
      "summary": "The 'Context Provider Hell' in React is a common issue faced by developers.",
      "blocks": [
        {
          "block": "![](/uploads/retina_1708x683_cover-react-context-api-4929b3703a1a7082d99b53eb1bbfc31f.png)\n\nThe 'Context Provider Hell' in React is a common issue faced by developers. It arises when multiple Context Providers are nested, which leads to increased complexity and a dense 'wrapper hell' that can be hard to debug and maintain. This article delves into this issue and provides effective strategies to overcome it.\n\n## What is Context in React?\n\nReact Context provides a way to pass data through the component tree without having to pass props down manually at every level, essentially addressing the problem of \"prop drilling\". A context in React is primarily comprised of two parts:\n\n1. Context.Provider: It allows components in the tree to access the context's value.\n2. Context.Consumer: It consumes the value from the nearest Provider in the tree.\n\nThis works beautifully for small to medium-sized applications, but problems start to emerge as the application scales up.\n\n## The 'Context Provider Hell'\n\nAs the complexity of your React application increases, you might find yourself having multiple context providers. Each provider has its responsibility, and as a consequence, your component tree starts looking something like this:\n\n<CodeBlock\nchildren=\"<Provider1>\n<Provider2>\n<Provider3>\n<Provider4>\n<Provider5>\n<Component />\n</Provider5>\n</Provider4>\n</Provider3>\n</Provider2>\n</Provider1>\n\"\n/>\n\nThis is known as the 'Context Provider Hell', and it can lead to several issues:\n\n1. Readability: It becomes difficult to understand the code. The complexity of the providers makes it hard to understand the context and the values being provided.\n2. Maintainability: It becomes harder to modify the code as your project grows.\n3. Performance: Each context provider can trigger a re-render in its consumers, even if the data they provide doesn't change. This can cause performance issues.\n\nSo, how do we mitigate these issues?\n\n## Mitigating the 'Context Provider Hell'\n\nHere are a few strategies to deal with the Context Provider Hell:\n\n### Combine Providers\n\nInstead of having many individual providers, combine them into a single one. This can be done by creating a utility function that combines all of the providers into a single component:\n\n\\<CodeBlock\nchildren=\"const AllProviders = ({ children }) => ( <Provider1> <Provider2> <Provider3> <Provider4> <Provider5>\n{children} </Provider5> </Provider4> </Provider3> </Provider2> </Provider1>\n);\n\n// Usage <AllProviders> <Component /> </AllProviders>\n\"\n/>\n\nThe above approach tidies up the code but does not completely solve the underlying issue. It merely shifts the problem to another location in the codebase.\n\n### Use a State Management Library\n\nAnother solution is to use a state management library, like Redux, MobX, or Zustand. These libraries abstract the provider pattern and handle updates efficiently to minimize re-renders.\n\n### Use Higher-Order Components (HOCs)\n\nHigher-Order Components are a way to reuse component logic. They take a component and return a new component with additional props or behavior. Here's how you can use HOCs to mitigate 'Context Provider Hell':\n\n\\<CodeBlock\nchildren=\"const withProviders = (Component) => {\nreturn () => ( <Provider1> <Provider2> <Provider3> <Provider4> <Provider5> <Component /> </Provider5> </Provider4> </Provider3> </Provider2> </Provider1>\n);\n};\n\n// Usage\nconst EnhancedComponent = withProviders(MyComponent);\n\n// Render EnhancedComponent <EnhancedComponent />\n\\`\\`\n\"\n/>\n\nIn conclusion, the power of Context in React is indisputable, providing a clear solution to prop drilling and simplifying data flow. However, it's crucial to be aware of the pitfalls of over-reliance on Context Providers, one of which is 'Context Provider Hell'.\n\nWhile the complexity may seem overwhelming, employing strategies such as combining providers, leveraging state management libraries, and using higher-order components (HOCs) can help you manage this issue effectively.\n\nThese solutions serve as stepping stones towards more readable, maintainable, and performant React applications. So, next time you find yourself facing the tangled labyrinth of 'Context Provider Hell', we hope these strategies will guide you through.\n\nAs software developers, we continually strive for code that is not just functional but is also manageable and scalable. Let's apply these practices to ensure our journey in building applications is more a well-orchestrated symphony than a chaotic cacophony.\n\nThank you for reading this article. We hope it sheds light on navigating through 'Context Provider Hell' in React. As you continue developing with React, keep these strategies in mind, continually striving for better code organization and performance. Happy coding!\n"
        }
      ],
      "tags": [
        "Provider",
        "React"
      ],
      "date": "2023-06-05T22:00:00.000Z"
    },
    {
      "title": "Async await and Fetch",
      "summary": "Ah, Async/await and fetch! The dynamic duo of JavaScript that can save you from callback hell.",
      "blocks": [
        {
          "block": "![](/uploads/asyncawait.jpeg)\n\nAh, Async/await and fetch! The dynamic duo of JavaScript that can save you from callback hell and make your code look like a superhero.\n\nThink of Async/await as the Batman to your Robin. It allows you to write asynchronous code that's easier to read and understand. It's like a trusty sidekick that helps you avoid callback disasters and keeps your code from turning into a supervillain.\n\nFetch, on the other hand, is like the Spider-Man to your Iron Man. It's a powerful tool that allows you to send HTTP requests and get data from APIs like a web-slinging hero. It's fast, it's efficient, and it's always ready to swing into action.\n\nTogether, Async/await and fetch make a formidable team that can conquer any coding challenge. Imagine them as the Avengers of your codebase, taking on the forces of bad syntax and spaghetti code.\n\nLet's take a closer look at these two superheroes in action.\n\nFirst up, Async/await. It's like a utility belt that allows you to write asynchronous code without getting tangled up in callback chains. With Async/await, you can wait for a promise to resolve before moving on to the next step. It's like having the Flash by your side, allowing you to move at lightning speed through your code.\n\nHere's an example of Async/await in action:\n\n\\<CodeBlock\nchildren=\"async function getData() {\nconst response = await fetch('[https://api.example.com/data](https://api.example.com/data)');\nconst data = await response.json();\nreturn data;\n}\n\ngetData().then(data => {\nconsole.log(data);\n});\"\n/>\n\nNow, onto fetch. It's like a shield that protects you from the dangers of unreliable APIs. Fetch allows you to send HTTP requests and receive responses in a clean and efficient way. It's like having Captain America by your side, shielding you from bad data and errors.\n\nHere's an example of fetch in action:\n\n<CodeBlock\nchildren=\"fetch('https://api.example.com/data')\n.then(response => response.json())\n.then(data => {\nconsole.log(data);\n});\"\n/>\n\nTogether, Async/await and fetch are a dynamic duo that can help you write better code and save the day. They're like the Batman and Robin, the Spider-Man and Iron Man, the Avengers of your codebase.\n\nSo next time you're facing a coding challenge, remember to call on the power of Async/await and fetch. They're always ready to lend a hand, like true superheroes.\n"
        }
      ],
      "tags": [
        "Promises",
        "Fetch API",
        "AsyncAwait"
      ],
      "date": "2023-03-26T22:00:00.000Z"
    },
    {
      "title": "Clone object in Javascript",
      "summary": "Often times, we want to create copies of variables for different purposes.",
      "blocks": [
        {
          "title": "Clone object in javascript",
          "block": "![](/uploads/VSMClonePattern.jpg)\n\nOften times, we want to create copies of variables for different purposes. There can be two different kinds of copies created - Shallow copy and Deep copy. Let's go over the terminologies and related examples:\n\n#### Shallow Copy\n\nShallow copying means it only copies the normal object values but nested values still use the reference to an original object. This means that modifications made in one place would affect both places.\n\nThere are two methods to do it. With Spread Operator (…) and Object.assign().\n\n<CodeBlock\nchildren=\"const obj = {a:10,b:20,c:{d:30}};\nconst shallowClone = {...obj};\nobj.c.d = 34; // updates the d property value\nconsole.log(obj); // {a:10,b:20,c:{d:34}}\nconsole.log(shallowClone); // {a:10,b:20,c:{d:34}}\"\n/>\n\n#### Deep Copy\n\nDeep copy method creates a copy where the source and the copied variable reference are completely different. It means that modifications made in one place would only affect the variable where we are making a change.\n\nif the objects/arrays are not nested, then we can achieve deep copy by using Spread (...) operator:\n\n\\<CodeBlock\nchildren=\"const first\\_person = {\nname: \"Manel\",\nage: 34,\n}\n\nconst second\\_person = { ...first\\_person };\n\nsecond\\_person.age = 35;\n\nconsole.log(first\\_person.age); // output: 34\nconsole.log(second\\_person.age); // output: 35\"\n/>\n\nIn case of nesting, the spread operator creates a shallow copy.\n\n###### If the objects/arrays are nested, then we can achieve deep copy by using JSON.parse() and JSON.stringify()\n\n\\<CodeBlock\nchildren=\"const obj = {a:10,b:20,c:{d:30}};\nconst deepClone = JSON.parse(JSON.stringify(obj));\nobj.c.d = 35;\n\n// d value is changed\nconsole.log(obj); // {a:10,b:20,c:{d:35}}\n\n// d value remains unchanged because there is no reference\nconsole.log(deepClone); // {a:10,b:20,c:{d:30}}\"\n/>\n\nReferences:\n\n* [https://developer.mozilla.org/en-US/docs/Glossary/Deep\\_copy](https://developer.mozilla.org/en-US/docs/Glossary/Deep_copy)\n* [https://developer.mozilla.org/en-US/docs/Glossary/Shallow\\_copy](https://developer.mozilla.org/en-US/docs/Glossary/Shallow_copy)\n"
        }
      ],
      "tags": [
        "Objects",
        "Javascript"
      ],
      "date": "2023-02-13T23:00:00.000Z"
    },
    {
      "title": "Good practices in React",
      "summary": " Here's a summary of an article discussing good practices in React.",
      "blocks": [
        {
          "block": "![](/uploads/lautaro-andreani-xkBaqlcqeb4-unsplash.jpg)\n\n### *Use an object for update multiple states*\n\nReact state keeps track of the data which when changed triggers the React component to re-render.  The more data you have to keep track of across your app.\n\n\\<CodeBlock\nchildren=\"const \\[state, setState] = useState({\ngender: \"\",\nname: \"\",\nage: 23\n});\n\nconst onClick = () => {\nsetState((prevState) => ({\n...prevState,\nage: prevState.age + 1,\nname: \"John\",\ngender: 'male',\n}));\n};\"\nlanguage=\"jsx\"\n/>\n\n### *Avoid using indexes as key props*\n\nWith keys, React can point which item has been changed, added, or removed from the array.\n\nIt is not recommended recommend using indexes for keys if the order of items may change. \n\n```javascript\nconst todoItems = todos.map((todo) =>\n  <li key={todo.id}>\n    {todo.text}\n  </li>\n  );\n/>\n\n```\n\n[https://reactjs.org/docs/lists-and-keys.html](https://reactjs.org/docs/lists-and-keys.html)\n\n### *Use object destructuring for props*\n\nIt's cleaner and easy to read\n\n<CodeBlock\nchildren=\"const Button = ({text}) => {\nreturn <button>{text}</button>;\n};\"\n/>\n\n### *Use Object Literals*\n\nIt's make our code more readable.\n\nIn this example we can't use ternary because there are more than two options and it's better to start using if's.\n\n\\<CodeBlock\nchildren=\"const {type} = animals\n\nconst components = {\nLION: AdminUser,\nCAT: EmployeeUser,\nDOG: NormalUser\n};\n\nconst Component = components\\[type];\n\nreturn <Component />;\"\n/>\n\n### *Keep render as clean as possible*\n\nMinimum logic inside render components.\n\n\\<CodeBlock\nchildren=\"const getUsers = () => dispatch(ACTION\\_GET\\_USERS)\n\nreturn ( <button onClick={getUsers}>\\\ngetUsers Button </button>\\\n)\"\n/>\n\n### *Use Template Literals*\n\nTry to avoid using string concatenation.\n\n\\<CodeBlock\nchildren=\"const animalDetails = `${animal.name} lives in ${animal.country} and eats ${animal.food}`\n\nreturn (\n\n  <div> {animalDetails} </div>  \n  )\"\n/>\n\n### *Conclusion*\n\nCongratulations if you’ve made it this far! I hope you learned a thing or two from this article.\n\nI hope you have a wonderful day!\n"
        }
      ],
      "tags": [
        "Javascript",
        "React"
      ],
      "date": "2022-12-09T23:00:00.000Z"
    }
  ]
}