{
  "rows": [
    {
      "title": "Async await and Fetch",
      "blocks": [
        {
          "block": "![](/uploads/asyncawait.jpeg \"\")\n\nAh, Async/await and fetch! The dynamic duo of JavaScript that can save you from callback hell and make your code look like a superhero.\n\nThink of Async/await as the Batman to your Robin. It allows you to write asynchronous code that's easier to read and understand. It's like a trusty sidekick that helps you avoid callback disasters and keeps your code from turning into a supervillain.\n\nFetch, on the other hand, is like the Spider-Man to your Iron Man. It's a powerful tool that allows you to send HTTP requests and get data from APIs like a web-slinging hero. It's fast, it's efficient, and it's always ready to swing into action.\n\nTogether, Async/await and fetch make a formidable team that can conquer any coding challenge. Imagine them as the Avengers of your codebase, taking on the forces of bad syntax and spaghetti code.\n\nLet's take a closer look at these two superheroes in action.\n\nFirst up, Async/await. It's like a utility belt that allows you to write asynchronous code without getting tangled up in callback chains. With Async/await, you can wait for a promise to resolve before moving on to the next step. It's like having the Flash by your side, allowing you to move at lightning speed through your code.\n\nHere's an example of Async/await in action:\n\n<CodeBlock\n  children=\"async function getData() {\n  const response = await fetch('https://api.example.com/data');\n  const data = await response.json();\n  return data;\n  }\n\n  getData().then(data => {\n  console.log(data);\n  });\"\n/>\n\nNow, onto fetch. It's like a shield that protects you from the dangers of unreliable APIs. Fetch allows you to send HTTP requests and receive responses in a clean and efficient way. It's like having Captain America by your side, shielding you from bad data and errors.\n\nHere's an example of fetch in action:\n\n<CodeBlock\n  children=\"fetch('https://api.example.com/data')\n  .then(response => response.json())\n  .then(data => {\n  console.log(data);\n  });\"\n/>\n\nTogether, Async/await and fetch are a dynamic duo that can help you write better code and save the day. They're like the Batman and Robin, the Spider-Man and Iron Man, the Avengers of your codebase.\n\nSo next time you're facing a coding challenge, remember to call on the power of Async/await and fetch. They're always ready to lend a hand, like true superheroes.\n"
        }
      ],
      "tags": [
        "Promises",
        "Fetch API",
        "AsyncAwait"
      ],
      "date": "2023-03-26T22:00:00.000Z"
    },
    {
      "title": "Clone object in Javascript",
      "blocks": [
        {
          "title": "Clone object in javascript",
          "block": "![](/uploads/VSMClonePattern.jpg \"\")\n\nOften times, we want to create copies of variables for different purposes. There can be two different kinds of copies created - Shallow copy and Deep copy. Let's go over the terminologies and related examples:\n\n#### Shallow Copy\n\nShallow copying means it only copies the normal object values but nested values still use the reference to an original object. This means that modifications made in one place would affect both places.\n\nThere are two methods to do it. With Spread Operator (…) and Object.assign().\n\n<CodeBlock\n  children=\"const obj = {a:10,b:20,c:{d:30}};\n  const shallowClone = {...obj};\n  obj.c.d = 34; // updates the d property value\n  console.log(obj); // {a:10,b:20,c:{d:34}}\n  console.log(shallowClone); // {a:10,b:20,c:{d:34}}\"\n/>\n\n#### Deep Copy\n\nDeep copy method creates a copy where the source and the copied variable reference are completely different. It means that modifications made in one place would only affect the variable where we are making a change.\n\nif the objects/arrays are not nested, then we can achieve deep copy by using Spread (...) operator:\n\n<CodeBlock\n  children=\"const first_person = {\n  name: &#x22;Manel&#x22;,\n  age: 34,\n  }\n\n  const second_person = { ...first_person };\n\n  second_person.age = 35;\n\n  console.log(first_person.age); // output: 34\n  console.log(second_person.age); // output: 35\"\n/>\n\nIn case of nesting, the spread operator creates a shallow copy.\n\n###### If the objects/arrays are nested, then we can achieve deep copy by using JSON.parse() and JSON.stringify()\n\n<CodeBlock\n  children=\"const obj = {a:10,b:20,c:{d:30}};\n  const deepClone = JSON.parse(JSON.stringify(obj));\n  obj.c.d = 35;\n\n  // d value is changed\n  console.log(obj); // {a:10,b:20,c:{d:35}}\n\n  // d value remains unchanged because there is no reference\n  console.log(deepClone); // {a:10,b:20,c:{d:30}}\"\n/>\n\nReferences:\n\n* [https://developer.mozilla.org/en-US/docs/Glossary/Deep\\_copy](https://developer.mozilla.org/en-US/docs/Glossary/Deep_copy \"\")\n* [https://developer.mozilla.org/en-US/docs/Glossary/Shallow\\_copy](https://developer.mozilla.org/en-US/docs/Glossary/Shallow_copy \"\")\n"
        }
      ],
      "tags": [
        "object",
        "javascript"
      ],
      "date": "2023-02-13T23:00:00.000Z"
    },
    {
      "title": "Good practices in React",
      "blocks": [
        {
          "block": "![](/uploads/lautaro-andreani-xkBaqlcqeb4-unsplash.jpg \"\")\n\n### *Use an object for update multiple states*\n\nReact state keeps track of the data which when changed triggers the React component to re-render.  The more data you have to keep track of across your app.\n\n<CodeBlock\n  children=\"const [state, setState] = useState({\n  gender: &#x22;&#x22;,\n  name: &#x22;&#x22;,\n  age: 23\n  });\n\n  const onClick = () => {\n  setState((prevState) => ({\n  ...prevState,\n  age: prevState.age + 1,\n  name: &#x22;John&#x22;,\n  gender: 'male',\n  }));\n  };\"\n  language=\"jsx\"\n/>\n\n### *Avoid using indexes as key props*\n\nWith keys, React can point which item has been changed, added, or removed from the array.\n\nIt is not recommended recommend using indexes for keys if the order of items may change. \n\n<CodeBlock\n  children=\"const todoItems = todos.map((todo) =>\n  <li key={todo.id}>\n  {todo.text}\n  </li>\n  );\"\n/>\n\n[https://reactjs.org/docs/lists-and-keys.html](https://reactjs.org/docs/lists-and-keys.html \"\")\n\n### *Use object destructuring for props*\n\nIt's cleaner and easy to read\n\n<CodeBlock\n  children=\"const Button = ({text}) => {\n  return <button>{text}</button>;\n  };\"\n/>\n\n### *Use Object Literals*\n\nIt's make our code more readable.\n\nIn this example we can't use ternary because there are more than two options and it's better to start using if's.\n\n<CodeBlock\n  children=\"const {type} = animals\n\n  const components = {\n  LION: AdminUser,\n  CAT: EmployeeUser,\n  DOG: NormalUser\n  };\n\n  const Component = components[type];\n\n  return <Component />;\"\n/>\n\n### *Keep render as clean as possible*\n\nMinimum logic inside render components.\n\n<CodeBlock\n  children=\"const getUsers = () => dispatch(ACTION_GET_USERS)\n\n  return (\n  <button onClick={getUsers}>  \n  getUsers Button\n  </button>  \n  )\"\n/>\n\n### *Use Template Literals*\n\nTry to avoid using string concatenation.\n\n<CodeBlock\n  children=\"const animalDetails = `${animal.name} lives in ${animal.country} and eats ${animal.food}`\n\n  return (\n  <div> {animalDetails} </div>  \n  )\"\n/>\n\n### *Conclusion*\n\nCongratulations if you’ve made it this far! I hope you learned a thing or two from this article.\n\nI hope you have a wonderful day!\n"
        }
      ],
      "tags": [
        "javascript",
        "react"
      ],
      "date": "2022-12-09T23:00:00.000Z"
    }
  ]
}