{
  "rows": [
    {
      "title": "React Context Provider Hell",
      "summary": "The 'Context Provider Hell' in React is a common issue faced by developers.",
      "blocks": [
        {
          "block": "![](/uploads/retina_1708x683_cover-react-context-api-4929b3703a1a7082d99b53eb1bbfc31f.png \"\")\n\nThe 'Context Provider Hell' in React is a common issue faced by developers. It arises when multiple Context Providers are nested, which leads to increased complexity and a dense 'wrapper hell' that can be hard to debug and maintain. This article delves into this issue and provides effective strategies to overcome it.\n\n## What is Context in React?\n\nReact Context provides a way to pass data through the component tree without having to pass props down manually at every level, essentially addressing the problem of \"prop drilling\". A context in React is primarily comprised of two parts:\n\n1. Context.Provider: It allows components in the tree to access the context's value.\n2. Context.Consumer: It consumes the value from the nearest Provider in the tree.\n\nThis works beautifully for small to medium-sized applications, but problems start to emerge as the application scales up.\n\n## The 'Context Provider Hell'\n\nAs the complexity of your React application increases, you might find yourself having multiple context providers. Each provider has its responsibility, and as a consequence, your component tree starts looking something like this:\n\n<CodeBlock\n  children=\"<Provider1>\n  <Provider2>\n  <Provider3>\n  <Provider4>\n  <Provider5>\n  <Component />\n  </Provider5>\n  </Provider4>\n  </Provider3>\n  </Provider2>\n  </Provider1>\n  \"\n/>\n\nThis is known as the 'Context Provider Hell', and it can lead to several issues:\n\n1. Readability: It becomes difficult to understand the code. The complexity of the providers makes it hard to understand the context and the values being provided.\n2. Maintainability: It becomes harder to modify the code as your project grows.\n3. Performance: Each context provider can trigger a re-render in its consumers, even if the data they provide doesn't change. This can cause performance issues.\n\nSo, how do we mitigate these issues?\n\n## Mitigating the 'Context Provider Hell'\n\nHere are a few strategies to deal with the Context Provider Hell:\n\n### Combine Providers\n\nInstead of having many individual providers, combine them into a single one. This can be done by creating a utility function that combines all of the providers into a single component:\n\n<CodeBlock\n  children=\"const AllProviders = ({ children }) => (\n  <Provider1>\n  <Provider2>\n  <Provider3>\n  <Provider4>\n  <Provider5>\n  {children}\n  </Provider5>\n  </Provider4>\n  </Provider3>\n  </Provider2>\n  </Provider1>\n  );\n\n  // Usage\n  <AllProviders>\n  <Component />\n  </AllProviders>\n  \"\n/>\n\nThe above approach tidies up the code but does not completely solve the underlying issue. It merely shifts the problem to another location in the codebase.\n\n### Use a State Management Library\n\nAnother solution is to use a state management library, like Redux, MobX, or Zustand. These libraries abstract the provider pattern and handle updates efficiently to minimize re-renders.\n\n### Use Higher-Order Components (HOCs)\n\nHigher-Order Components are a way to reuse component logic. They take a component and return a new component with additional props or behavior. Here's how you can use HOCs to mitigate 'Context Provider Hell':\n\n<CodeBlock\n  children=\"const withProviders = (Component) => {\n  return () => (\n  <Provider1>\n  <Provider2>\n  <Provider3>\n  <Provider4>\n  <Provider5>\n  <Component />\n  </Provider5>\n  </Provider4>\n  </Provider3>\n  </Provider2>\n  </Provider1>\n  );\n  };\n\n  // Usage\n  const EnhancedComponent = withProviders(MyComponent);\n\n  // Render EnhancedComponent\n  <EnhancedComponent />\n  ``\n  \"\n/>\n\nIn conclusion, the power of Context in React is indisputable, providing a clear solution to prop drilling and simplifying data flow. However, it's crucial to be aware of the pitfalls of over-reliance on Context Providers, one of which is 'Context Provider Hell'.\n\nWhile the complexity may seem overwhelming, employing strategies such as combining providers, leveraging state management libraries, and using higher-order components (HOCs) can help you manage this issue effectively.\n\nThese solutions serve as stepping stones towards more readable, maintainable, and performant React applications. So, next time you find yourself facing the tangled labyrinth of 'Context Provider Hell', we hope these strategies will guide you through.\n\nAs software developers, we continually strive for code that is not just functional but is also manageable and scalable. Let's apply these practices to ensure our journey in building applications is more a well-orchestrated symphony than a chaotic cacophony.\n\nThank you for reading this article. We hope it sheds light on navigating through 'Context Provider Hell' in React. As you continue developing with React, keep these strategies in mind, continually striving for better code organization and performance. Happy coding!\n"
        }
      ],
      "tags": [
        "Provider",
        "React"
      ],
      "date": "2023-06-05T22:00:00.000Z"
    },
    {
      "title": "Async await and Fetch",
      "summary": "Ah, Async/await and fetch! The dynamic duo of JavaScript that can save you from callback hell.",
      "blocks": [
        {
          "block": "![](/uploads/asyncawait.jpeg \"\")\n\nAh, Async/await and fetch! The dynamic duo of JavaScript that can save you from callback hell and make your code look like a superhero.\n\nThink of Async/await as the Batman to your Robin. It allows you to write asynchronous code that's easier to read and understand. It's like a trusty sidekick that helps you avoid callback disasters and keeps your code from turning into a supervillain.\n\nFetch, on the other hand, is like the Spider-Man to your Iron Man. It's a powerful tool that allows you to send HTTP requests and get data from APIs like a web-slinging hero. It's fast, it's efficient, and it's always ready to swing into action.\n\nTogether, Async/await and fetch make a formidable team that can conquer any coding challenge. Imagine them as the Avengers of your codebase, taking on the forces of bad syntax and spaghetti code.\n\nLet's take a closer look at these two superheroes in action.\n\nFirst up, Async/await. It's like a utility belt that allows you to write asynchronous code without getting tangled up in callback chains. With Async/await, you can wait for a promise to resolve before moving on to the next step. It's like having the Flash by your side, allowing you to move at lightning speed through your code.\n\nHere's an example of Async/await in action:\n\n<CodeBlock\n  children=\"async function getData() {\n  const response = await fetch('https://api.example.com/data');\n  const data = await response.json();\n  return data;\n  }\n\n  getData().then(data => {\n  console.log(data);\n  });\"\n/>\n\nNow, onto fetch. It's like a shield that protects you from the dangers of unreliable APIs. Fetch allows you to send HTTP requests and receive responses in a clean and efficient way. It's like having Captain America by your side, shielding you from bad data and errors.\n\nHere's an example of fetch in action:\n\n<CodeBlock\n  children=\"fetch('https://api.example.com/data')\n  .then(response => response.json())\n  .then(data => {\n  console.log(data);\n  });\"\n/>\n\nTogether, Async/await and fetch are a dynamic duo that can help you write better code and save the day. They're like the Batman and Robin, the Spider-Man and Iron Man, the Avengers of your codebase.\n\nSo next time you're facing a coding challenge, remember to call on the power of Async/await and fetch. They're always ready to lend a hand, like true superheroes.\n"
        }
      ],
      "tags": [
        "Promises",
        "Fetch API",
        "AsyncAwait"
      ],
      "date": "2023-03-26T22:00:00.000Z"
    },
    {
      "title": "Clone object in Javascript",
      "summary": "Often times, we want to create copies of variables for different purposes.",
      "blocks": [
        {
          "title": "Clone object in javascript",
          "block": "![](/uploads/VSMClonePattern.jpg \"\")\n\nOften times, we want to create copies of variables for different purposes. There can be two different kinds of copies created - Shallow copy and Deep copy. Let's go over the terminologies and related examples:\n\n#### Shallow Copy\n\nShallow copying means it only copies the normal object values but nested values still use the reference to an original object. This means that modifications made in one place would affect both places.\n\nThere are two methods to do it. With Spread Operator (â€¦) and Object.assign().\n\n<CodeBlock\n  children=\"const obj = {a:10,b:20,c:{d:30}};\n  const shallowClone = {...obj};\n  obj.c.d = 34; // updates the d property value\n  console.log(obj); // {a:10,b:20,c:{d:34}}\n  console.log(shallowClone); // {a:10,b:20,c:{d:34}}\"\n/>\n\n#### Deep Copy\n\nDeep copy method creates a copy where the source and the copied variable reference are completely different. It means that modifications made in one place would only affect the variable where we are making a change.\n\nif the objects/arrays are not nested, then we can achieve deep copy by using Spread (...) operator:\n\n<CodeBlock\n  children=\"const first_person = {\n  name: &#x22;Manel&#x22;,\n  age: 34,\n  }\n\n  const second_person = { ...first_person };\n\n  second_person.age = 35;\n\n  console.log(first_person.age); // output: 34\n  console.log(second_person.age); // output: 35\"\n/>\n\nIn case of nesting, the spread operator creates a shallow copy.\n\n###### If the objects/arrays are nested, then we can achieve deep copy by using JSON.parse() and JSON.stringify()\n\n<CodeBlock\n  children=\"const obj = {a:10,b:20,c:{d:30}};\n  const deepClone = JSON.parse(JSON.stringify(obj));\n  obj.c.d = 35;\n\n  // d value is changed\n  console.log(obj); // {a:10,b:20,c:{d:35}}\n\n  // d value remains unchanged because there is no reference\n  console.log(deepClone); // {a:10,b:20,c:{d:30}}\"\n/>\n\nReferences:\n\n* [https://developer.mozilla.org/en-US/docs/Glossary/Deep\\_copy](https://developer.mozilla.org/en-US/docs/Glossary/Deep_copy \"\")\n* [https://developer.mozilla.org/en-US/docs/Glossary/Shallow\\_copy](https://developer.mozilla.org/en-US/docs/Glossary/Shallow_copy \"\")\n"
        }
      ],
      "tags": [
        "Objects",
        "Javascript"
      ],
      "date": "2023-02-13T23:00:00.000Z"
    },
    {
      "title": "Good practices in React",
      "summary": " Here's a summary of an article discussing good practices in React.",
      "blocks": [
        {
          "block": "![](/uploads/lautaro-andreani-xkBaqlcqeb4-unsplash.jpg \"\")\n\n### *Use an object for update multiple states*\n\nReact state keeps track of the data which when changed triggers the React component to re-render.  The more data you have to keep track of across your app.\n\n<CodeBlock\n  children=\"const [state, setState] = useState({\n  gender: &#x22;&#x22;,\n  name: &#x22;&#x22;,\n  age: 23\n  });\n\n  const onClick = () => {\n  setState((prevState) => ({\n  ...prevState,\n  age: prevState.age + 1,\n  name: &#x22;John&#x22;,\n  gender: 'male',\n  }));\n  };\"\n  language=\"jsx\"\n/>\n\n### *Avoid using indexes as key props*\n\nWith keys, React can point which item has been changed, added, or removed from the array.\n\nIt is not recommended recommend using indexes for keys if the order of items may change.Â \n\n<CodeBlock\n  children=\"const todoItems = todos.map((todo) =>\n  <li key={todo.id}>\n  {todo.text}\n  </li>\n  );\"\n/>\n\n[https://reactjs.org/docs/lists-and-keys.html](https://reactjs.org/docs/lists-and-keys.html \"\")\n\n### *Use object destructuring for props*\n\nIt's cleaner and easy to read\n\n<CodeBlock\n  children=\"const Button = ({text}) => {\n  return <button>{text}</button>;\n  };\"\n/>\n\n### *Use Object Literals*\n\nIt's make our code more readable.\n\nIn this example we can't use ternary because there are more than two options and it's better to start using if's.\n\n<CodeBlock\n  children=\"const {type} = animals\n\n  const components = {\n  LION: AdminUser,\n  CAT: EmployeeUser,\n  DOG: NormalUser\n  };\n\n  const Component = components[type];\n\n  return <Component />;\"\n/>\n\n### *Keep render as clean as possible*\n\nMinimum logic inside render components.\n\n<CodeBlock\n  children=\"const getUsers = () => dispatch(ACTION_GET_USERS)\n\n  return (\n  <button onClick={getUsers}>  \n  getUsers Button\n  </button>  \n  )\"\n/>\n\n### *Use Template Literals*\n\nTry to avoid using string concatenation.\n\n<CodeBlock\n  children=\"const animalDetails = `${animal.name} lives in ${animal.country} and eats ${animal.food}`\n\n  return (\n  <div> {animalDetails} </div>  \n  )\"\n/>\n\n### *Conclusion*\n\nCongratulations if youâ€™ve made it this far! I hope you learned a thing or two from this article.\n\nI hope you have a wonderful day!\n"
        }
      ],
      "tags": [
        "Javascript",
        "React"
      ],
      "date": "2022-12-09T23:00:00.000Z"
    }
  ]
}